# Bool

let true = \iftrue iffalse.iftrue in

let false = \iftrue iffalse.iffalse in

let not = \a.a false true in

let and = \a b.a b false in

let or = \a b.a true b in

# Function

let id = \x.x in

let comp = \f g x.f (g x) in

let flip = \f x y.f y x in

let fix = \f.(\x.f (x x))(\x.f (x x)) in

# Pair

let pair = \a b ifpair.ifpair a b in

let fst = \pair.pair \a b.a in

let snd = \pair.pair \a b.b in

# List

let nil = \ifnil ifcons.ifnil in

let cons = \head tail ifnil ifcons.ifcons head tail in

let head = \list.list
  nil
  \head tail.head in

let tail = \list.list
  nil
  \head tail.tail in

let foldr = \f init list.list
  init
  \head tail.f head (foldr f init tail) in

let foldl = \f init list.list
  init
  \head tail.foldl f (f init head) tail in

let map = \f.foldr (comp cons f) nil in

let rev = foldl (flip cons) nil in

# Int
# Balanced ternary as described in:
# Mogensen, T.Æ. (2001). An Investigation of Compact and Efficient Number Representations in the
# Pure Lambda Calculus. In: Bjørner, D., Broy, M., Zamulin, A.V. (eds) Perspectives of System
# Informatics. PSI 2001. Lecture Notes in Computer Science, vol 2244. Springer, Berlin, Heidelberg.
# https://doi.org/10.1007/3-540-45575-2_20

# TODO omit definitions of 0, 1, and -1 once we have syntax sugar for numbers.

let 0 = \z x- x0 x+.z in

let 1 = \z x- x0 x+.x+ in

let -1 = \z x- x0 x+.x- in

let up- = \n z x- x0 x+.x- (n z x- x0 x+) in

let up0 = \n z x- x0 x+.x0 (n z x- x0 x+) in

let up+ = \n z x- x0 x+.x+ (n z x- x0 x+) in

let zero? = \n.n true (\x.false) id (\x.false) in

let pos? =
  let Z = pair false false in
  let A- = \p.p \done res.done p (pair true false) in
  let A0 = id in
  let A+ = \p.p \done res.done p (pair true true) in
  \n.snd (n Z A- A0 A+) in

let neg? =
  let Z = pair false false in
  let A- = \p.p \done res.done p (pair true true) in
  let A0 = id in
  let A+ = \p.p \done res.done p (pair true false) in
  \n.snd (n Z A- A0 A+) in

let inc =
  let Z = pair 0 1 in
  let A- = \p.p \n m.pair (up- n) (up0 n) in
  let A0 = \p.p \n m.pair (up0 n) (up+ n) in
  let A+ = \p.p \n m.pair (up+ n) (up- m) in
  \n.snd (n Z A- A0 A+) in

let dec =
  let Z = pair 0 -1 in
  let A- = \p.p \n m.pair (up- n) (up+ m) in
  let A0 = \p.p \n m.pair (up0 n) (up- n) in
  let A+ = \p.p \n m.pair (up+ n) (up0 n) in
  \n.snd (n Z A- A0 A+) in

let lift =
  let A- = \n z x- x0 x+.x- n in
  let A0 = \n z x- x0 x+.x0 n in
  let A+ = \n z x- x0 x+.x+ n in
  \n.n 0 A- A0 A+ in

let drop =
  let A- = \m.up- (drop m) in
  let A0 = \m.up0 (drop m) in
  let A+ = \m.up+ (drop m) in
  \n.n 0 A- A0 A+ in

# We could define this later as `\x y.zero? (sub x y)` but it's a nice example of the technique used
# to implement add, while being slightly simpler than add.
let eq =
  let Z = \n.zero? (drop n) in
  let A- = \e n.n false (\m.e m) (\m.false) (\m.false) in
  let A0 = \e n.n (e n) (\m.false) (\m.e m) (\m.false) in
  let A+ = \e n.n false (\m.false) (\m.false) (\m.e m) in
  let go = \n.n Z A- A0 A+ in
  \x y.go x (lift y) in

let add =
  let trit- = \x- x0 x+.x- in
  let trit0 = \x- x0 x+.x0 in
  let trit+ = \x- x0 x+.x+ in
  let Z = \n c.c (dec (drop n)) (drop n) (inc (drop n)) in
  let C = \a n.a n trit0 in
  let B-- = \a c m.c (up0 (a m trit-)) (up+ (a m trit-)) (up- (a m trit0)) in
  let B0- = \a c m.c (up+ (a m trit-)) (up- (a m trit0)) (up0 (a m trit0)) in
  let B00 = \a c m.c (up- (a m trit0)) (up0 (a m trit0)) (up+ (a m trit0)) in
  let B0+ = \a c m.c (up0 (a m trit0)) (up+ (a m trit0)) (up- (a m trit+)) in
  let B++ = \a c m.c (up+ (a m trit0)) (up- (a m trit+)) (up0 (a m trit+)) in
  let A- = \a n c.n (B0- a c n) (B-- a c) (B0- a c) (B00 a c) in
  let A0 = \a n c.n (B00 a c n) (B0- a c) (B00 a c) (B0+ a c) in
  let A+ = \a n c.n (B0+ a c n) (B00 a c) (B0+ a c) (B++ a c) in
  let go = \n.C (n Z A- A0 A+) in
  \x y.go x (lift y) in

let neg = \n z x- x0 x+.n z x+ x0 x- in

let sub = \x y.add x (neg y) in

let mul = \n m.n 0 (\n.sub (up0 n) m) (\n.up0 n) (\n.add (up0 n) m) in

let lt = \x y.neg? (sub x y) in

let gt = \x y.pos? (sub x y) in

let lte = \x y.not (gt x y) in

let gte = \x y.not (lt x y) in
