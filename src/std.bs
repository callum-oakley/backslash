# Bool

let true = \iftrue iffalse.iftrue in

let false = \iftrue iffalse.iffalse in

let not = \a.a false true in

let and = \a b.a b false in

let or = \a b.a true b in

# Function

let id = \x.x in

let comp = \f g x.f (g x) in

let flip = \f x y.f y x in

let fix = \f.(\x.f (x x))(\x.f (x x)) in

# Pair

let pair = \a b ifpair.ifpair a b in

let fst = \pair.pair \a b.a in

let snd = \pair.pair \a b.b in

# List

let nil = \ifnil ifcons.ifnil in

let cons = \head tail ifnil ifcons.ifcons head tail in

let head = \list.list
  nil
  \head tail.head in

let tail = \list.list
  nil
  \head tail.tail in

let foldr = \f init list.list
  init
  \head tail.f head (foldr f init tail) in

let foldl = \f init list.list
  init
  \head tail.foldl f (f init head) tail in

let map = \f.foldr (comp cons f) nil in

let rev = foldl (flip cons) nil in

# Int
# Balanced ternary as described in:
# Mogensen, T.Æ. (2001). An Investigation of Compact and Efficient Number Representations in the
# Pure Lambda Calculus. In: Bjørner, D., Broy, M., Zamulin, A.V. (eds) Perspectives of System
# Informatics. PSI 2001. Lecture Notes in Computer Science, vol 2244. Springer, Berlin, Heidelberg.
# https://doi.org/10.1007/3-540-45575-2_20

# TODO omit definitions of 0, 1, and -1 once we have syntax sugar for numbers.

let 0 = \z x- x0 x+.z in

let 1 = \z x- x0 x+.x+ in

let -1 = \z x- x0 x+.x- in

let shift- = \n z x- x0 x+.x- (n z x- x0 x+) in

let shift0 = \n z x- x0 x+.x0 (n z x- x0 x+) in

let shift+ = \n z x- x0 x+.x+ (n z x- x0 x+) in

let zero? = \n.n true (\x.false) id (\x.false) in

let inc =
  let Z = pair 0 1 in
  let A- = \p.p (\n m.pair (shift- n) (shift0 n)) in
  let A0 = \p.p (\n m.pair (shift0 n) (shift+ n)) in
  let A+ = \p.p (\n m.pair (shift+ n) (shift- m)) in
  \n.snd (n Z A- A0 A+) in

let dec =
  let Z = pair 0 -1 in
  let A- = \p.p (\n m.pair (shift- n) (shift+ m)) in
  let A0 = \p.p (\n m.pair (shift0 n) (shift- n)) in
  let A+ = \p.p (\n m.pair (shift+ n) (shift0 n)) in
  \n.snd (n Z A- A0 A+) in

let lift =
  let A- = \n z x- x0 x+.x- n in
  let A0 = \n z x- x0 x+.x0 n in
  let A+ = \n z x- x0 x+.x+ n in
  \n.n 0 A- A0 A+ in

let drop =
  let A- = \m.shift- (drop m) in
  let A0 = \m.shift0 (drop m) in
  let A+ = \m.shift+ (drop m) in
  \n.n 0 A- A0 A+ in

let eq? =
  let Z = \n.zero? (drop n) in
  let A- = \e n.n false (\m.e m) (\m.false) (\m.false) in
  let A0 = \e n.n (e n) (\m.false) (\m.e m) (\m.false) in
  let A+ = \e n.n false (\m.false) (\m.false) (\m.e m) in
  let go = \n.n Z A- A0 A+ in
  \x y.go x (lift y) in

let add =
  let trit- = \x- x0 x+.x- in
  let trit0 = \x- x0 x+.x0 in
  let trit+ = \x- x0 x+.x+ in
  let Z = \n c.c (dec (drop n)) (drop n) (inc (drop n)) in
  let C = \a n.a n trit0 in
  let B-- = \a c m.c (shift0 (a m trit-)) (shift+ (a m trit-)) (shift- (a m trit0)) in
  let B0- = \a c m.c (shift+ (a m trit-)) (shift- (a m trit0)) (shift0 (a m trit0)) in
  let B00 = \a c m.c (shift- (a m trit0)) (shift0 (a m trit0)) (shift+ (a m trit0)) in
  let B0+ = \a c m.c (shift0 (a m trit0)) (shift+ (a m trit0)) (shift- (a m trit+)) in
  let B++ = \a c m.c (shift+ (a m trit0)) (shift- (a m trit+)) (shift0 (a m trit+)) in
  let A- = \a n c.n (B0- a c n) (B-- a c) (B0- a c) (B00 a c) in
  let A0 = \a n c.n (B00 a c n) (B0- a c) (B00 a c) (B0+ a c) in
  let A+ = \a n c.n (B0+ a c n) (B00 a c) (B0+ a c) (B++ a c) in
  let go = \n.C (n Z A- A0 A+) in
  \x y.go x (lift y) in

let neg = \n z x- x0 x+.n z x+ x0 x- in

let sub = \x y.add x (neg y) in

let mul = \n m.n 0 (\n.sub (shift0 n) m) (\n.shift0 n) (\n.add (shift0 n) m) in
